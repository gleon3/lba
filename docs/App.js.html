<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: App.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: App.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { useEffect } from "react";
import { useState } from "react";
import './App.css';
import { Production, Grammar, convert_to_kuroda, grammar_to_lba, is_kuroda, lba_eliminate_x } from "./lba.js";

/**
 * A component that displays a start state.
 * @Component
 * 
 * @typedef {Object} StartStateProps
 * @property {Object} position - The x and y position of the state.
 * @property {Number} radius - The radius of the outer circle of the state.
 * @property {String} name - The name of the state.
 * @property {Number} transition_length - The length of the transition to the start state.
 *
 * @param {StartStateProps} props
 * @returns {JSX.Element}
 */
const StartState = ({ position, radius, name, transition_length }) => {
  const statePosition = {
    x: position.x,
    y: position.y + transition_length,
  }

  return(
    &lt;svg>
      &lt;State position={statePosition} radius={radius} name={name}>&lt;/State>
      &lt;Transition startPoint={position} endPoint={statePosition} radius={radius} label={["start"]}>&lt;/Transition>
    &lt;/svg>
  )
}

/**
 * A component that displays a state.
 *
 * @typedef {Object} StateProps
 * @property {Object} position - The x and y position of the state.
 * @property {Number} radius - The radius of the outer circle of the state.
 * @property {String} name - The name of the string.
 *
 * @param {StateProps} props
 * @returns {JSX.Element}
 */
const State = ({ position, radius, name }) => {
  return(
    &lt;svg>
      &lt;circle cx={position.x} cy={position.y} r={radius} fill="none" stroke="black" />
      &lt;text x={position.x} y={position.y} textAnchor="middle">{name}&lt;/text>
    &lt;/svg>
  )
}

/**
 * A component that displays a end state.
 *
 * @typedef {Object} EndStateProps
 * @property {Object} position - The x and y position of the state.
 * @property {Number} radius - The radius of the outer circle of the state.
 * @property {String} name - The name of the end state.
 *
 * @param {EndStateProps} props
 * @returns {JSX.Element}
 */
const EndState = ({ position, radius, name }) => {
  return(
    &lt;svg>
      &lt;State position={position} radius={radius} name={name}>&lt;/State>
      &lt;circle cx={position.x} cy={position.y} r={radius-5} fill="none" stroke="black" />
    &lt;/svg>
  )
}

/**
 * A component that displays the arrowhead of a transition.
 *
 * @typedef {Object} TransitionProps
 * @property {Object} startPoint - The x and y position of the state the transition starts at.
 * @property {Object} endPoint - The x and y position of the state the transition ends at.
 * @property {Number} angle - The angle of the arrow.
 * @property {Number} arrowLength - The length of the arrow.
 *
 * @param {TransitionProps} props
 * @returns {JSX.Element}
 */
const ArrowHead = ({startPoint, endPoint, angle, arrowLength}) => {
  let dirx = startPoint.x - endPoint.x
  let diry = startPoint.y - endPoint.y

  let dir_length = Math.sqrt(dirx*dirx+diry*diry)

  //normalize
  dirx = dirx/dir_length
  diry = diry/dir_length

  let ax = dirx * Math.cos(angle) - diry * Math.sin(angle)
  let ay = dirx * Math.sin(angle) + diry * Math.cos(angle)
          
  let bx = dirx * Math.cos(angle) + diry * Math.sin(angle)
  let by = - dirx * Math.sin(angle) + diry * Math.cos(angle)
  
  return(
    &lt;svg>
      &lt;line x1={endPoint.x} y1={endPoint.y} x2={endPoint.x + arrowLength*ax} y2={endPoint.y + arrowLength*ay} stroke="black" strokeWidth={3}>&lt;/line>
      &lt;line x1={endPoint.x} y1={endPoint.y} x2={endPoint.x + arrowLength*bx} y2={endPoint.y + arrowLength*by} stroke="black" strokeWidth={3}>&lt;/line>
    &lt;/svg>
  )
}

/**
 * A component that displays a transition between two states.
 *
 * @typedef {Object} TransitionProps
 * @property {Object} startPoint - The x and y position of the state the transition starts at.
 * @property {Object} endPoint - The x and y position of the state the transition ends at.
 * @property {Number} radius - The radius of the states.
 * @property {String[]} label - The label of the transition.
 *
 * @param {TransitionProps} props
 * @returns {JSX.Element}
 */
const Transition = ({ startPoint, endPoint, radius, label }) => {
  const [isFocused, setFocus] = useState(false);

  if(startPoint.x == endPoint.x &amp;&amp; startPoint.y == endPoint.y){ //self transition
    const transitionStart = {
      x: startPoint.x + radius,
      y: startPoint.y
    }
  
    const transitionEnd = transitionStart

    const urlString = transitionStart.x + "," + transitionStart.y + "," + transitionEnd.x + "," + transitionEnd.y

    return(
      &lt;svg pointerEvents="stroke" onMouseOver={() => setFocus(true)} onMouseLeave={() => setFocus(false)} fill={isFocused ? "red" : "black"}>
        &lt;marker
            id={"arrow" + urlString} 
            viewBox="0 0 10 10"
            refX="5"
            refY="5"
            markerWidth="6"
            markerHeight="6"
            orient="auto-start-reverse">
            &lt;path d="M 0 0 L 10 5 L 0 10 z" />
        &lt;/marker>
        &lt;path d={'M ' + transitionStart.x + ' ' + transitionStart.y + ' q 125 -12.5 0 -25'} stroke={isFocused ? "red" : "#aaa"} fill="none" strokeWidth={2} markerEnd={"url(#arrow" + urlString + ")"}/>
        &lt;text x={transitionStart.x} y={transitionStart.y - radius} textAnchor="middle">{
          label.map(value => {
            return &lt;tspan key={value} x={transitionStart.x + 2*radius} dy='13'>{value}&lt;/tspan>
          })
        }
        &lt;/text>
      &lt;/svg>
    )
  }
  else if(startPoint.x == endPoint.x &amp;&amp; startPoint.y >= endPoint.y){ //transition to earlier already drawn state on the same column
    const transitionStart = {
      x: startPoint.x - radius,
      y: startPoint.y
    }
  
    const transitionEnd = {
      x: endPoint.x - radius,
      y: endPoint.y
    }

    const urlString = transitionStart.x + "," + transitionStart.y + "," + transitionEnd.x + "," + transitionEnd.y

    return(
      &lt;svg pointerEvents="stroke" onMouseOver={() => setFocus(true)} onMouseLeave={() => setFocus(false)} fill={isFocused ? "red" : "black"}>
          &lt;marker
            id={"arrow" + urlString}
            viewBox="0 0 10 10"
            refX="5"
            refY="5"
            markerWidth="6"
            markerHeight="6"
            orient="auto-start-reverse">
            &lt;path d="M 0 0 L 10 5 L 0 10 z" />
          &lt;/marker>
          &lt;path id={urlString} d={'M ' + transitionStart.x + ' ' + transitionStart.y + ' S ' + (transitionStart.x - 2*radius) + ' ' + ((transitionStart.y + transitionEnd.y)/2) + ' ' + transitionEnd.x + ' ' + transitionEnd.y} stroke={isFocused ? "red" : "#aaa"} strokeWidth={2} fill="transparent" markerEnd={"url(#arrow" + urlString + ")"}/>
          &lt;text fill={isFocused ? "red" : "black"} textAnchor="middle">
            &lt;textPath   href={"#" + urlString} startOffset="50%">{
              label.map(element => {
                return &lt;tspan key={element} x='0' dy='15'>{element}&lt;/tspan>
              })}
            &lt;/textPath>
          &lt;/text>
        &lt;/svg>
    )
  }else{
    const directionX = (startPoint.x &lt;= endPoint.x) ? 1 : -1
    const directionY = (startPoint.y &lt;= endPoint.y) ? 1 : -1

    const transitionStart = {
      x: startPoint.x,
      y: startPoint.y + radius * directionY
    }
  
    const transitionEnd = {
      x: endPoint.x,
      y: endPoint.y - radius * directionY
    }

    const urlString = transitionStart.x + "," + transitionStart.y + "," + transitionEnd.x + "," + transitionEnd.y

    return(
      &lt;svg fill={isFocused ? "red" : "black"} pointerEvents="stroke" onMouseOver={() => setFocus(true)} onMouseLeave={() => setFocus(false)}>
        &lt;marker 
          id={"arrow" + urlString} 
          viewBox="0 0 10 10"
          refX="5"
          refY="5"
          markerWidth="6"
          markerHeight="6"
          orient="auto-start-reverse">
          &lt;path d="M 0 0 L 10 5 L 0 10 z"/>
        &lt;/marker>
        &lt;path id={urlString} d={'M ' + transitionStart.x + ' ' + transitionStart.y + ' S ' + ((directionX == -1 &amp;&amp; directionY == 1) ? (transitionStart.x + ' ' + transitionEnd.y) : (transitionEnd.x + ' ' + transitionStart.y)) + ' ' + transitionEnd.x + ' ' + transitionEnd.y} stroke={isFocused ? "red" : "#aaa"} strokeWidth={2} fill="transparent" markerEnd={"url(#arrow" + urlString + ")"}/>
        &lt;text textAnchor="middle">
          &lt;textPath href={"#" + urlString} startOffset="50%">{
            label.map(element => {
              return &lt;tspan key={element} x='0' dy='15'>{element}&lt;/tspan>
            })}
          &lt;/textPath>
        &lt;/text>
      &lt;/svg>
    )
  }
}

//TOdo: rework
const LBA_Graph = ({ lba, radius, distanceY, distanceX }) => {
  const lbaGraph = []
  const alreadyDrawn = new Map()

  let height = distanceY + 2*radius
  let width = 0

  let j = 0
  let i = 1

  function drawTransition(startState) {

    if (height &lt;= j * distanceY + (100 + 2 * radius)) {
      height += distanceY
    }

    let transitions = lba.delta.get(startState)

    if(transitions) {
      let startX = alreadyDrawn.get(startState)[0]
      let startY = alreadyDrawn.get(startState)[1] + 1
      for (let [key, v] of transitions) {
        if (alreadyDrawn.get(key)) {
          if (startState == key) {
            //self transition
            const startPoint = {
              x: i*distanceX,
              y: distanceY +j * distanceY
            }

            lbaGraph.push(
              &lt;Transition key={'self transition from state ' + startState + ' at ' + startPoint} startPoint={startPoint} endPoint={startPoint} radius={radius} label={v}>&lt;/Transition>
            )

          } else {
            //transition to state that already has been drawn
            let stateX = alreadyDrawn.get(key)[0]
            let stateY = alreadyDrawn.get(key)[1] + 1

            const startPoint = {
              x: i*distanceX,
              y: distanceY + j*distanceY,
            }

            const endPoint = {
              x: stateX*distanceX,
              y: stateY*distanceY
            }

            lbaGraph.push(&lt;Transition key={'transition from state ' + startState + ' at ' + startPoint + ' to ' + endPoint} startPoint={startPoint} endPoint={endPoint} radius={radius} label={v}>&lt;/Transition>)
          }
        } else {
          j += 1

          const startPoint = {
            x: startX*distanceX,
            y: startY * distanceY
          }
          
          const endPoint = {
            x: i * distanceX,
            y: distanceY + j * distanceY,
          }
          
          if(key == lba.endStates){
            lbaGraph.push(
              &lt;svg key={'state ' + key  + ' from ' + startPoint + ' to ' + endPoint}>
                &lt;EndState position={endPoint} radius={radius} name={key}>&lt;/EndState>
                &lt;Transition startPoint={startPoint} endPoint={endPoint} radius={radius} label={v}>&lt;/Transition>
              &lt;/svg>
            )
          }else{
            lbaGraph.push(
              &lt;svg key={'end state ' + key  + ' from ' + startPoint + ' to ' + endPoint}>
                &lt;State position={endPoint} radius={radius} name={key}>&lt;/State>
                &lt;Transition startPoint={startPoint} endPoint={endPoint} radius={radius} label={v}>&lt;/Transition>
              &lt;/svg>
            )
          }
          

          if (!alreadyDrawn.get(key)) {
            alreadyDrawn.set(key, [i, j])
          }

          drawTransition(key)
          i += 1
          j -= 1
        }

      }
      if (width &lt; i * distanceX) {
        width += distanceX  
      }
      i = startX
    }
  }


  if (lba) {
    const stateRadius = 50
    const startPosition = {
      x: distanceX, 
      y: 0,
    }

    lbaGraph.push(&lt;StartState key={'start state'} position={startPosition} radius={stateRadius} name={lba.startState} transition_length={distanceY}>&lt;/StartState>)
    alreadyDrawn.set(lba.startState, [1, 0])
    drawTransition(lba.startState)
  }
  return (
    &lt;svg width={width} height={height}>{lbaGraph}&lt;/svg>
  )
}

//TOdo: rework
function App() {
  const [startValue, setStartValue] = useState('')
  const [nonterminalValue, setNonterminalValue] = useState('')
  const [terminalValue, setTerminalValue] = useState('')
  const [productionValue, setProductionValue] = useState('')

  const [lba, setLBA] = useState('')
  const [eliminateX, setEliminateX] = useState('')

  const [kurodaGrammar, setKurodaGrammar] = useState('')

  function handleSubmit(e) {
    e.preventDefault();

    const nonterminals = nonterminalValue.split(' ').join('').split(',')
    const terminals = terminalValue.split(' ').join('').split(',')
    let productions = productionValue.split(' ').join('').split(',')

    productions = handleProductions(productions)

    let grammar = new Grammar(nonterminals, terminals, productions, startValue)

    console.log(grammar)

    console.log('old grammar:')
    for (let production of productions) {
      console.log(production.left + " -> " + production.right)
    }

    let kuroda_grammar = is_kuroda(grammar) ? grammar : convert_to_kuroda(grammar)

    setKurodaGrammar(kuroda_grammar)

    console.log('\nnew grammar:')
    for (let production of kuroda_grammar.productions) {
      console.log(production.left + " -> " + production.right)
    }

    setLBA(grammar_to_lba(kuroda_grammar))
    setEliminateX(lba_eliminate_x(kuroda_grammar))
    


    console.log(lba.delta)
    console.log('M = ', eliminateX)
  }

  function handleStartValue(startValue) {
    //TODO: check if startValue input is correct
  }

  function handleNonterminals(nonterminals) {
    //TODO: check if nonterminals input is correct
  }

  function handleTerminals(terminals) {
    //TODO: check if terminals input is correct
  }

  function handleProductions(productionsString) {
    //TODO: check if production input is correct

    let productions = []

    for (let prod of productionsString) {
      prod = prod.trim()

      const left = prod.split('->')[0]
      const right = prod.split('->')[1]

      const production = new Production(left.split(''), right.split(''))

      productions.push(production)
    }

    return productions
  }

  return (
    &lt;div>
      &lt;div className="menu gui-element">
        &lt;legend>Menu&lt;/legend>
        &lt;label>start:&lt;/label>
        &lt;textarea onChange={(e) => setStartValue(e.target.value)}>&lt;/textarea>
        &lt;label>nonterminals:&lt;/label>
        &lt;textarea onChange={(e) => setNonterminalValue(e.target.value)}>&lt;/textarea>
        &lt;label>terminals:&lt;/label>
        &lt;textarea onChange={(e) => setTerminalValue(e.target.value)}>&lt;/textarea>
        &lt;label>productions:&lt;/label>
        &lt;textarea rows={5} onChange={(e) => setProductionValue(e.target.value)}>&lt;/textarea>
        &lt;button onClick={handleSubmit}>submit&lt;/button>
      &lt;/div>
      &lt;div className="grammar-info gui-element">
        &lt;legend>grammar-info&lt;/legend>
        &lt;pre>
          {JSON.stringify(kurodaGrammar, null, 2)}
        &lt;/pre>
        &lt;p>{kurodaGrammar.start}&lt;/p>
        &lt;p>add old grammar, is kuroda? if no add kuroda grammar if yes explain how it is already&lt;/p>
      &lt;/div>
      &lt;div className="lba-info gui-element">
        &lt;legend>lba-info&lt;/legend>
        &lt;pre>
          {JSON.stringify(lba, null, 2)}
        &lt;/pre>
        &lt;label>M=&lt;/label>
        &lt;pre>
          {JSON.stringify(eliminateX, null, 2)}
        &lt;/pre>
      &lt;/div>
      &lt;div className="LBA gui-element">
        &lt;legend>Linear Bounded Automaton&lt;/legend>
        &lt;LBA_Graph lba={lba} radius={50} distanceX={300} distanceY={300}>&lt;/LBA_Graph>
      &lt;/div>
    &lt;/div>
  );
}

export default App;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Grammar.html">Grammar</a></li><li><a href="LBA.html">LBA</a></li><li><a href="Production.html">Production</a></li></ul><h3>Global</h3><ul><li><a href="global.html#convert_to_kuroda">convert_to_kuroda</a></li><li><a href="global.html#grammar_to_lba">grammar_to_lba</a></li><li><a href="global.html#is_kuroda">is_kuroda</a></li><li><a href="global.html#lba_eliminate_x">lba_eliminate_x</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Mar 24 2025 16:32:52 GMT+0100 (Mitteleuropäische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
